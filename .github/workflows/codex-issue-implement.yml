name: Codex Issue Implement

on:
  issue_comment:
    types:
      - created

permissions:
  actions: read
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: codex-issue-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  preflight:
    if: github.event.issue.pull_request == null
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      is_spec: ${{ steps.gate.outputs.is_spec }}
      authorized: ${{ steps.gate.outputs.authorized }}
      run_ready: ${{ steps.gate.outputs.run_ready }}
    steps:
      - name: Evaluate command and actor authorization
        id: gate
        uses: actions/github-script@v7
        env:
          CODEX_ALLOWED_ACTORS: ${{ vars.CODEX_ALLOWED_ACTORS }}
        with:
          script: |
            const issueNumber = context.issue.number;
            const body = (context.payload.comment?.body || "").replace(/\r\n/g, "\n");
            const firstLine = (body.split("\n")[0] || "").trim();
            const shouldRun = firstLine === "/codex run";
            const isSpec = firstLine === "/codex spec";
            core.setOutput("should_run", shouldRun ? "true" : "false");
            core.setOutput("is_spec", isSpec ? "true" : "false");
            core.setOutput("run_ready", "false");

            if (!shouldRun && !isSpec) {
              core.setOutput("authorized", "false");
              core.info("Not a Codex command. Skip.");
              return;
            }

            const allowed = (process.env.CODEX_ALLOWED_ACTORS || "")
              .split(",")
              .map((v) => v.trim())
              .filter(Boolean);

            if (allowed.length === 0) {
              core.setOutput("authorized", "false");
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: issueNumber,
                body: "Codex自動実装を開始できません。`CODEX_ALLOWED_ACTORS` が未設定です。",
              });
              return;
            }

            const actor = context.actor;
            const authorized = allowed.includes(actor);
            core.setOutput("authorized", authorized ? "true" : "false");
            if (!authorized) {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: issueNumber,
                body: `@${actor} は \`${firstLine}\` を実行する権限がありません。`,
              });
              return;
            }

            if (!shouldRun) {
              return;
            }

            const labels = (context.payload.issue?.labels || []).map((l) => l.name);
            const runReady = labels.includes("codex:spec-approved");
            core.setOutput("run_ready", runReady ? "true" : "false");
            if (!runReady) {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: issueNumber,
                body: "`/codex run` の前に、allowlist 登録者が `/codex spec` を投稿し、Spec QA を通過させてください（`codex:spec-approved` ラベルが必要です）。",
              });
            }

  spec_feedback:
    needs:
      - preflight
    if: needs.preflight.outputs.is_spec == 'true' && needs.preflight.outputs.authorized == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Extract posted /codex spec body
        id: extract_posted_spec
        run: |
          SPEC_PATH="$RUNNER_TEMP/posted-codex-spec.md"
          SPEC_PATH="$SPEC_PATH" node <<'NODE'
          const fs = require("fs");
          const payload = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH, "utf8"));
          const raw = (payload.comment?.body || "").replace(/\r\n/g, "\n");
          const content = raw.split("\n").slice(1).join("\n").trim();
          fs.writeFileSync(process.env.SPEC_PATH, `${content}\n`, "utf8");
          NODE
          echo "spec_path=$SPEC_PATH" >> "$GITHUB_OUTPUT"

      - name: Run Spec QA for posted /codex spec
        id: qa
        env:
          SPEC_INPUT_PATH: ${{ steps.extract_posted_spec.outputs.spec_path }}
        run: |
          RESULT_PATH="$RUNNER_TEMP/spec-qa-result.json"
          node .github/scripts/spec-qa.mjs "$RESULT_PATH" "$SPEC_INPUT_PATH"

      - name: Render clarification comment
        if: steps.qa.outputs.status == 'BLOCK'
        run: |
          COMMENT_PATH="$RUNNER_TEMP/spec-qa-comment.md"
          node .github/scripts/render-spec-qa-comment.mjs "${{ steps.qa.outputs.result_path }}" "$COMMENT_PATH"

      - name: Comment PASS and mark spec approved
        if: steps.qa.outputs.status == 'PASS'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.issue.number;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: issueNumber,
              body: "`/codex spec` を受理しました（Spec QA: PASS）。allowlist 登録者が `/codex run` を投稿すると実装を開始します。",
            });

            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number: issueNumber,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number: issueNumber,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }

            await safeAdd("codex:spec-approved");
            await safeRemove("codex:needs-clarification");

      - name: Comment BLOCK and clear spec approval
        if: steps.qa.outputs.status == 'BLOCK'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const issue_number = context.issue.number;
            const commentPath = `${process.env.RUNNER_TEMP}/spec-qa-comment.md`;
            const body = fs.readFileSync(commentPath, "utf8");

            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body,
            });

            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }

            await safeAdd("codex:needs-clarification");
            await safeRemove("codex:spec-approved");

  spec_qa:
    needs:
      - preflight
    if: needs.preflight.outputs.should_run == 'true' && needs.preflight.outputs.authorized == 'true' && needs.preflight.outputs.run_ready == 'true'
    runs-on: ubuntu-latest
    outputs:
      qa_status: ${{ steps.qa.outputs.status }}
      qa_result_path: ${{ steps.qa.outputs.result_path }}
    env:
      CODEX_ALLOWED_ACTORS: ${{ vars.CODEX_ALLOWED_ACTORS }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Extract latest /codex spec
        id: extract_spec
        run: |
          SPEC_PATH="$RUNNER_TEMP/latest-codex-spec.md"
          node .github/scripts/extract-latest-codex-spec.mjs "$SPEC_PATH"

      - name: Notify when spec is missing
        if: steps.extract_spec.outputs.status == 'BLOCK'
        uses: actions/github-script@v7
        env:
          REASON: ${{ steps.extract_spec.outputs.reason }}
        with:
          script: |
            const issue_number = context.issue.number;
            const reason = process.env.REASON || "allowlist登録者による有効な /codex spec が見つかりません。";
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body: `Codex自動実装を開始できませんでした。\n\n理由: ${reason}\n\nallowlist登録者が次の形式でコメントしてください:\n\`\`\`\n/codex spec\n## 背景/目的\n...\n## 受入条件\n- ...\n## 非対象\n- ...\n\`\`\`\nその後、allowlist登録者が \`/codex run\` を実行してください。`,
            });

      - name: Stop when no valid spec is found
        if: steps.extract_spec.outputs.status == 'BLOCK'
        run: exit 1

      - name: Spec QA
        id: qa
        env:
          SPEC_INPUT_PATH: ${{ steps.extract_spec.outputs.spec_path }}
        run: |
          RESULT_PATH="$RUNNER_TEMP/spec-qa-result.json"
          node .github/scripts/spec-qa.mjs "$RESULT_PATH" "$SPEC_INPUT_PATH"

      - name: Recommend split for size:L
        if: contains(join(github.event.issue.labels.*.name, ','), 'size:L')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: "このIssueは `size:L` です。必要なら受入条件を分割して複数Issueに分けてください。"
            });

      - name: Render clarification comment
        if: steps.qa.outputs.status == 'BLOCK'
        run: |
          COMMENT_PATH="$RUNNER_TEMP/spec-qa-comment.md"
          node .github/scripts/render-spec-qa-comment.mjs "${{ steps.qa.outputs.result_path }}" "$COMMENT_PATH"

      - name: Comment and relabel on BLOCK
        if: steps.qa.outputs.status == 'BLOCK'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const issue_number = context.issue.number;
            const commentPath = `${process.env.RUNNER_TEMP}/spec-qa-comment.md`;
            const body = fs.readFileSync(commentPath, "utf8");

            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body,
            });

            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }

            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }

            await safeAdd("codex:needs-clarification");
            await safeRemove("codex:spec-approved");
            await safeRemove("codex:in-progress");
            await safeRemove("codex:reviewing");

  implement_and_review:
    needs:
      - spec_qa
    if: needs.spec_qa.outputs.qa_status == 'PASS'
    runs-on: ubuntu-latest
    env:
      ISSUE_NUMBER: ${{ github.event.issue.number }}
      ISSUE_TITLE: ${{ github.event.issue.title }}
      CODEX_RUNNER_COMMAND: ${{ vars.CODEX_RUNNER_COMMAND }}
      CODEX_ALLOWED_ACTORS: ${{ vars.CODEX_ALLOWED_ACTORS }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install Codex CLI
        run: |
          npm install -g @openai/codex

      - name: Verify Codex CLI
        run: |
          if command -v codex >/dev/null 2>&1; then
            codex --version
          else
            npx -y @openai/codex --version
          fi

      - name: Extract latest /codex spec
        id: extract_spec
        run: |
          SPEC_PATH="$RUNNER_TEMP/latest-codex-spec.md"
          node .github/scripts/extract-latest-codex-spec.mjs "$SPEC_PATH"

      - name: Stop when no valid spec is found
        if: steps.extract_spec.outputs.status == 'BLOCK'
        run: |
          echo "Valid /codex spec not found."
          exit 1

      - name: Setup git identity
        run: |
          git config user.name "codex[bot]"
          git config user.email "codex[bot]@users.noreply.github.com"

      - name: Validate Codex runner configuration
        run: |
          if [ -z "${CODEX_RUNNER_COMMAND}" ]; then
            echo "CODEX_RUNNER_COMMAND repository variable is required."
            exit 1
          fi
          if [[ "${CODEX_RUNNER_COMMAND}" != *"{mode}"* ]]; then
            echo "CODEX_RUNNER_COMMAND must include {mode}."
            exit 1
          fi
          if [[ "${CODEX_RUNNER_COMMAND}" != *"{prompt_file}"* ]] && [[ "${CODEX_RUNNER_COMMAND}" != *"CODEX_PROMPT_FILE"* ]]; then
            echo "CODEX_RUNNER_COMMAND must reference prompt input via {prompt_file} or \$CODEX_PROMPT_FILE."
            exit 1
          fi
          if [[ "${CODEX_RUNNER_COMMAND}" != *"{output_file}"* ]] && [[ "${CODEX_RUNNER_COMMAND}" != *"CODEX_OUTPUT_FILE"* ]]; then
            echo "CODEX_RUNNER_COMMAND must reference review output via {output_file} or \$CODEX_OUTPUT_FILE."
            exit 1
          fi
          if [[ "${CODEX_RUNNER_COMMAND}" == *"smoke {mode}"* ]]; then
            echo "CODEX_RUNNER_COMMAND looks like a smoke stub. Set a real Codex execution command."
            exit 1
          fi
          if [[ "${CODEX_RUNNER_COMMAND}" == *"run-codex.sh"* ]] && [ ! -f "./scripts/run-codex.sh" ]; then
            echo "CODEX_RUNNER_COMMAND references run-codex.sh, but ./scripts/run-codex.sh was not found."
            echo "Ensure scripts/run-codex.sh exists on the default branch used by this workflow."
            exit 1
          fi
          if ! command -v codex >/dev/null 2>&1 && ! command -v npx >/dev/null 2>&1; then
            echo "Neither 'codex' nor 'npx' command is available in PATH."
            exit 1
          fi

      - name: Mark in progress
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }
            await safeAdd("codex:in-progress");
            await safeRemove("codex:needs-clarification");

      - name: Select latest v* base branch
        id: select_base
        continue-on-error: true
        run: |
          git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          node .github/scripts/select-base-branch.mjs

      - name: Notify when base branch is missing
        if: steps.select_base.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body: "`origin/v*` ブランチが見つからないため自動実装を停止しました。`vX[.Y[.Z]]` 形式のブランチを作成して再実行してください。"
            });
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }
            await safeRemove("codex:in-progress");

      - name: Stop when no v* branch exists
        if: steps.select_base.outcome == 'failure'
        run: exit 1

      - name: Create working branch
        id: create_branch
        run: |
          set -euo pipefail
          BASE="${{ steps.select_base.outputs.base_branch }}"
          WORK="codex/issue-${ISSUE_NUMBER}"

          git switch "$BASE"

          # Reuse existing issue branch on reruns to avoid duplicate PRs.
          if git ls-remote --exit-code --heads origin "$WORK" >/dev/null 2>&1; then
            git fetch origin "$WORK"
            git switch -C "$WORK" "origin/$WORK"
          else
            git switch -c "$WORK"
          fi
          echo "work_branch=$WORK" >> "$GITHUB_OUTPUT"

      - name: Validate runner script on switched branch
        run: |
          if [[ "${CODEX_RUNNER_COMMAND}" == *"run-codex.sh"* ]] && [ ! -f "./scripts/run-codex.sh" ]; then
            echo "CODEX_RUNNER_COMMAND references run-codex.sh, but ./scripts/run-codex.sh was not found on the selected base/work branch."
            exit 1
          fi

      - name: Debug working directory before implement
        run: |
          pwd
          ls -la
          ls -la scripts || true

      - name: Prepare implement prompt
        run: |
          set -euo pipefail
          TMP_DIR="$RUNNER_TEMP/codex-${GITHUB_RUN_ID}"
          mkdir -p "$TMP_DIR"
          node .github/scripts/prepare-codex-prompt.mjs implement "$TMP_DIR/implement.md"
          echo "tmp_dir=$TMP_DIR" >> "$GITHUB_OUTPUT"
        id: prep
        env:
          BASE_BRANCH: ${{ steps.select_base.outputs.base_branch }}
          WORK_BRANCH: ${{ steps.create_branch.outputs.work_branch }}
          SPEC_INPUT_PATH: ${{ steps.extract_spec.outputs.spec_path }}

      - name: Run Codex implement
        run: |
          node .github/scripts/run-codex-command.mjs implement "${{ steps.prep.outputs.tmp_dir }}/implement.md"

      - name: Commit implementation
        id: commit_impl
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain)" ]; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git add -A
          SHORT_TITLE="$(echo "$ISSUE_TITLE" | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g' | cut -c1-72)"
          git commit -m "feat(codex): implement #${ISSUE_NUMBER} ${SHORT_TITLE}"
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

      - name: Stop when no implementation diff
        if: steps.commit_impl.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body: "Codex 実装を実行しましたが変更差分が生成されませんでした。`/codex spec` を具体化して `/codex run` を再実行してください。"
            });
            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }
            await safeAdd("codex:needs-clarification");
            await safeRemove("codex:in-progress");

      - name: Mark reviewing
        if: steps.commit_impl.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }
            await safeAdd("codex:reviewing");
            await safeRemove("codex:in-progress");

      - name: Review and fix loop (max 2 rounds)
        if: steps.commit_impl.outputs.has_changes == 'true'
        run: |
          set -euo pipefail
          TMP_DIR="${{ steps.prep.outputs.tmp_dir }}"
          BASE_BRANCH="${{ steps.select_base.outputs.base_branch }}"
          WORK_BRANCH="${{ steps.create_branch.outputs.work_branch }}"

          for ROUND in 1 2; do
            REVIEW_PROMPT="$TMP_DIR/review-${ROUND}.md"
            FIX_PROMPT="$TMP_DIR/fix-${ROUND}.md"
            REVIEW_NOTES="$TMP_DIR/review-round-${ROUND}.md"

            REVIEW_ROUND="$ROUND" \
            REVIEW_NOTES_PATH="$REVIEW_NOTES" \
            BASE_BRANCH="$BASE_BRANCH" \
            WORK_BRANCH="$WORK_BRANCH" \
            SPEC_INPUT_PATH="${{ steps.extract_spec.outputs.spec_path }}" \
            node .github/scripts/prepare-codex-prompt.mjs review "$REVIEW_PROMPT"

            CODEX_OUTPUT_PATH="$REVIEW_NOTES" \
            node .github/scripts/run-codex-command.mjs review "$REVIEW_PROMPT"

            if [ ! -f "$REVIEW_NOTES" ]; then
              printf '%s\n' \
                '判定: NO_FINDINGS' \
                'Summary:' \
                '- レビュー出力が生成されなかったため、修正対象はありませんでした。' \
                > "$REVIEW_NOTES"
            fi

            REVIEW_ROUND="$ROUND" \
            REVIEW_NOTES_PATH="$REVIEW_NOTES" \
            BASE_BRANCH="$BASE_BRANCH" \
            WORK_BRANCH="$WORK_BRANCH" \
            SPEC_INPUT_PATH="${{ steps.extract_spec.outputs.spec_path }}" \
            node .github/scripts/prepare-codex-prompt.mjs fix "$FIX_PROMPT"

            node .github/scripts/run-codex-command.mjs fix "$FIX_PROMPT"

            if [ -z "$(git status --porcelain)" ]; then
              echo "No review fixes in round ${ROUND}."
              break
            fi

            git add -A
            git commit -m "fix(codex-review): address review for #${ISSUE_NUMBER} (round ${ROUND})"
          done

      - name: Push branch
        if: steps.commit_impl.outputs.has_changes == 'true'
        run: |
          git push origin "${{ steps.create_branch.outputs.work_branch }}"

      - name: Render PR body
        if: steps.commit_impl.outputs.has_changes == 'true'
        id: pr_body
        run: |
          PR_BODY_PATH="${{ steps.prep.outputs.tmp_dir }}/pr-body.md"
          REVIEW1="${{ steps.prep.outputs.tmp_dir }}/review-round-1.md"
          REVIEW2="${{ steps.prep.outputs.tmp_dir }}/review-round-2.md"
          BASE_BRANCH="${{ steps.select_base.outputs.base_branch }}" \
          WORK_BRANCH="${{ steps.create_branch.outputs.work_branch }}" \
          QA_STATUS="${{ needs.spec_qa.outputs.qa_status }}" \
          REVIEW_ROUND1_PATH="$REVIEW1" \
          REVIEW_ROUND2_PATH="$REVIEW2" \
          node .github/scripts/render-pr-body.mjs "$PR_BODY_PATH"
          echo "path=$PR_BODY_PATH" >> "$GITHUB_OUTPUT"

      - name: Create draft PR
        if: steps.commit_impl.outputs.has_changes == 'true'
        id: create_pr
        uses: actions/github-script@v7
        env:
          BASE_BRANCH: ${{ steps.select_base.outputs.base_branch }}
          WORK_BRANCH: ${{ steps.create_branch.outputs.work_branch }}
          PR_BODY_PATH: ${{ steps.pr_body.outputs.path }}
        with:
          script: |
            const fs = require("fs");
            const issue_number = context.issue.number;
            const issue_title = context.payload.issue.title;
            const base = process.env.BASE_BRANCH;
            const work = process.env.WORK_BRANCH;
            const body = fs.readFileSync(process.env.PR_BODY_PATH, "utf8");
            const title = `[codex] #${issue_number} ${issue_title}`;
            const head = `${context.repo.owner}:${work}`;
            const issueRefPattern = new RegExp(`(^|\\D)#${issue_number}(?!\\d)\\b`);
            const closesPattern = new RegExp(`\\bCloses\\s+#${issue_number}(?!\\d)\\b`, "i");

            const existing = await github.rest.pulls.list({
              ...context.repo,
              state: "open",
              head,
              base,
            });

            if (existing.data.length > 0) {
              core.info(`PR already exists: #${existing.data[0].number}`);
              core.setOutput("pr_number", String(existing.data[0].number));
              core.setOutput("pr_url", existing.data[0].html_url);
              return;
            }

            // Fallback: search open PRs by issue number marker to prevent PR duplication.
            const openPulls = await github.paginate(github.rest.pulls.list, {
              ...context.repo,
              state: "open",
              per_page: 100,
            });
            const matchedByIssue = openPulls.find((pr) => {
              const prTitle = pr.title || "";
              const prBody = pr.body || "";
              return issueRefPattern.test(prTitle) || closesPattern.test(prBody);
            });
            if (matchedByIssue) {
              core.info(`PR for issue marker already exists: #${matchedByIssue.number}`);
              core.setOutput("pr_number", String(matchedByIssue.number));
              core.setOutput("pr_url", matchedByIssue.html_url);
              return;
            }

            const created = await github.rest.pulls.create({
              ...context.repo,
              title,
              head: work,
              base,
              body,
              draft: true,
            });

            core.setOutput("pr_number", String(created.data.number));
            core.setOutput("pr_url", created.data.html_url);

      - name: Final relabel and notify
        if: steps.commit_impl.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const prNumber = Number(`${{ steps.create_pr.outputs.pr_number }}`);
            const prUrl = `${{ steps.create_pr.outputs.pr_url }}`;

            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body: `Draft PR を作成しました: #${prNumber}\n${prUrl}`,
            });

            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }

            await safeAdd("codex:ready-pr");
            await safeRemove("codex:reviewing");
            await safeRemove("codex:in-progress");

  notify_failure:
    needs:
      - preflight
      - spec_qa
      - implement_and_review
    if: >-
      always() &&
      needs.preflight.outputs.should_run == 'true' &&
      needs.preflight.outputs.authorized == 'true' &&
      needs.preflight.outputs.run_ready == 'true' &&
      needs.implement_and_review.result == 'failure'
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure on Issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            let failedJobName = "(特定できませんでした)";
            let failedJobUrl = runUrl;
            let failedStepNames = [];

            try {
              const jobs = await github.paginate(github.rest.actions.listJobsForWorkflowRun, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId,
                per_page: 100,
              });
              const failedJob = jobs.find(
                (job) =>
                  ["failure", "cancelled", "timed_out", "action_required"].includes(job.conclusion) &&
                  job.name !== "notify_failure",
              );
              if (failedJob) {
                failedJobName = failedJob.name || failedJobName;
                failedJobUrl = failedJob.html_url || failedJobUrl;
                failedStepNames = (failedJob.steps || [])
                  .filter((step) =>
                    ["failure", "cancelled", "timed_out", "action_required"].includes(step.conclusion),
                  )
                  .map((step) => step.name)
                  .slice(0, 5);
              }
            } catch (e) {
              core.warning(`Failed to collect failed job details: ${e.message}`);
            }

            const body = [
              "Codex 自動実装が失敗しました。",
              "",
              `- Workflow Run: ${runUrl}`,
              `- 失敗ジョブ: ${failedJobName}`,
              `- 失敗ジョブログ: ${failedJobUrl}`,
              `- 失敗ステップ: ${failedStepNames.length > 0 ? failedStepNames.join(", ") : "(ログを確認してください)"}`,
              "- 主な確認ポイント: `CODEX_RUNNER_COMMAND`、`scripts/run-codex.sh` の存在、`codex` CLI の PATH",
              "- 詳細は上記Runのログを確認してください。",
            ].join("\n");

            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body,
            });

            async function safeAdd(name) {
              try {
                await github.rest.issues.addLabels({
                  ...context.repo,
                  issue_number,
                  labels: [name],
                });
              } catch (e) {
                core.warning(`Failed to add label ${name}: ${e.message}`);
              }
            }
            async function safeRemove(name) {
              try {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number,
                  name,
                });
              } catch (e) {
                if (e.status !== 404) {
                  core.warning(`Failed to remove label ${name}: ${e.message}`);
                }
              }
            }

            await safeAdd("codex:needs-clarification");
            await safeRemove("codex:in-progress");
            await safeRemove("codex:reviewing");
